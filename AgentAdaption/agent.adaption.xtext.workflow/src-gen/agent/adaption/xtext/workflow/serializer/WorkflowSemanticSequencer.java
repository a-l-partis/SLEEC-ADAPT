/*
 * generated by Xtext 2.40.0
 */
package agent.adaption.xtext.workflow.serializer;

import agent.adaption.xtext.workflow.services.WorkflowGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import workflowspec.Atom;
import workflowspec.BoolComp;
import workflowspec.BoolValue;
import workflowspec.Decision;
import workflowspec.GuardedWorkflow;
import workflowspec.Loop;
import workflowspec.MBoolExpr;
import workflowspec.Not;
import workflowspec.RelComp;
import workflowspec.Sequence;
import workflowspec.Task;
import workflowspec.Value;
import workflowspec.WorkflowStructure;
import workflowspec.WorkflowspecPackage;

@SuppressWarnings("all")
public class WorkflowSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private WorkflowGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == WorkflowspecPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case WorkflowspecPackage.ATOM:
				sequence_Atom(context, (Atom) semanticObject); 
				return; 
			case WorkflowspecPackage.BOOL_COMP:
				sequence_BoolComp(context, (BoolComp) semanticObject); 
				return; 
			case WorkflowspecPackage.BOOL_VALUE:
				sequence_BoolValue(context, (BoolValue) semanticObject); 
				return; 
			case WorkflowspecPackage.DECISION:
				sequence_Decision(context, (Decision) semanticObject); 
				return; 
			case WorkflowspecPackage.GUARDED_WORKFLOW:
				sequence_GuardedWorkflow(context, (GuardedWorkflow) semanticObject); 
				return; 
			case WorkflowspecPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case WorkflowspecPackage.MBOOL_EXPR:
				sequence_MBoolExpr_Impl(context, (MBoolExpr) semanticObject); 
				return; 
			case WorkflowspecPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case WorkflowspecPackage.REL_COMP:
				sequence_RelComp(context, (RelComp) semanticObject); 
				return; 
			case WorkflowspecPackage.SEQUENCE:
				sequence_Sequence(context, (Sequence) semanticObject); 
				return; 
			case WorkflowspecPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case WorkflowspecPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case WorkflowspecPackage.WORKFLOW_STRUCTURE:
				sequence_WorkflowStructure(context, (WorkflowStructure) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     MBoolExpr returns Atom
	 *     Atom returns Atom
	 *
	 * Constraint:
	 *     measureID=EString?
	 * </pre>
	 */
	protected void sequence_Atom(ISerializationContext context, Atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MBoolExpr returns BoolComp
	 *     BoolComp returns BoolComp
	 *
	 * Constraint:
	 *     (op=BoolOp? right=MBoolExpr? left=MBoolExpr?)
	 * </pre>
	 */
	protected void sequence_BoolComp(ISerializationContext context, BoolComp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MBoolExpr returns BoolValue
	 *     BoolValue returns BoolValue
	 *
	 * Constraint:
	 *     value?='value'?
	 * </pre>
	 */
	protected void sequence_BoolValue(ISerializationContext context, BoolValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Decision
	 *     Decision returns Decision
	 *
	 * Constraint:
	 *     (options+=GuardedWorkflow options+=GuardedWorkflow*)
	 * </pre>
	 */
	protected void sequence_Decision(ISerializationContext context, Decision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GuardedWorkflow returns GuardedWorkflow
	 *
	 * Constraint:
	 *     (body=Workflow guard=MBoolExpr)
	 * </pre>
	 */
	protected void sequence_GuardedWorkflow(ISerializationContext context, GuardedWorkflow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowspecPackage.Literals.GUARDED_WORKFLOW__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowspecPackage.Literals.GUARDED_WORKFLOW__BODY));
			if (transientValues.isValueTransient(semanticObject, WorkflowspecPackage.Literals.GUARDED_WORKFLOW__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowspecPackage.Literals.GUARDED_WORKFLOW__GUARD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGuardedWorkflowAccess().getBodyWorkflowParserRuleCall_3_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getGuardedWorkflowAccess().getGuardMBoolExprParserRuleCall_5_0(), semanticObject.getGuard());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     loop=GuardedWorkflow
	 * </pre>
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowspecPackage.Literals.LOOP__LOOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowspecPackage.Literals.LOOP__LOOP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopAccess().getLoopGuardedWorkflowParserRuleCall_3_0(), semanticObject.getLoop());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MBoolExpr returns MBoolExpr
	 *     MBoolExpr_Impl returns MBoolExpr
	 *
	 * Constraint:
	 *     {MBoolExpr}
	 * </pre>
	 */
	protected void sequence_MBoolExpr_Impl(ISerializationContext context, MBoolExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MBoolExpr returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     (op=EString? expr=MBoolExpr?)
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MBoolExpr returns RelComp
	 *     RelComp returns RelComp
	 *
	 * Constraint:
	 *     (op=RelOp? left=MBoolExpr? right=MBoolExpr?)
	 * </pre>
	 */
	protected void sequence_RelComp(ISerializationContext context, RelComp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Sequence
	 *     Sequence returns Sequence
	 *
	 * Constraint:
	 *     (subworkflows+=Workflow subworkflows+=Workflow*)
	 * </pre>
	 */
	protected void sequence_Sequence(ISerializationContext context, Sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Task
	 *     Task returns Task
	 *
	 * Constraint:
	 *     ID=EString
	 * </pre>
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowspecPackage.Literals.TASK__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowspecPackage.Literals.TASK__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskAccess().getIDEStringParserRuleCall_3_0(), semanticObject.getID());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MBoolExpr returns Value
	 *     Value returns Value
	 *
	 * Constraint:
	 *     value=EInt?
	 * </pre>
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowStructure returns WorkflowStructure
	 *
	 * Constraint:
	 *     workflowspec=Workflow
	 * </pre>
	 */
	protected void sequence_WorkflowStructure(ISerializationContext context, WorkflowStructure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowspecPackage.Literals.WORKFLOW_STRUCTURE__WORKFLOWSPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowspecPackage.Literals.WORKFLOW_STRUCTURE__WORKFLOWSPEC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkflowStructureAccess().getWorkflowspecWorkflowParserRuleCall_3_0(), semanticObject.getWorkflowspec());
		feeder.finish();
	}
	
	
}
